TCG Interpreter (TCI) - Copyright (c) 2011 Stefan Weil.

This file is released under the BSD license.

1) Introduction

TCG (Tiny Code Generator) is a code generator which translates
code fragments ("basic blocks") from target code (any of the
targets supported by QEMU) to a code representation which
can be run on a host.

QEMU can create native code for some hosts (arm, i386, ia64, ppc, ppc64,
s390, sparc, x86_64). For others, unofficial host support was written.

By adding a code generator for a virtual machine and using an
interpreter for the generated bytecode, it is possible to
support (almost) any host.

This is what TCI (Tiny Code Interpreter) does.

2) Usage

For hosts without native TCG, the interpreter TCI must be enabled by

        configure --enable-tcg-interpreter

If configure is called without --enable-tcg-interpreter, it will
suggest using this option. Setting it automatically would need
additional code in configure which must be fixed when new native TCG
implementations are added.

System emulation should work on any 32 or 64 bit host.
User mode emulation might work. Maybe a new linker script (*.ld)
is needed. Byte order might be wrong (on big endian hosts)
and need fixes in configure.

For hosts with native TCG, the interpreter TCI can be enabled by

        configure --enable-tcg-interpreter

The only difference from running QEMU with TCI to running without TCI
should be speed. Especially during development of TCI, it was very
useful to compare runs with and without TCI. Create /tmp/qemu.log by

        qemu-system-i386 -d in_asm,op_opt,cpu -D /tmp/qemu.log -singlestep

once with interpreter and once without interpreter and compare the
resulting qemu.log files.

Hosts with native TCG can also enable TCI by claiming to be unsupported:

        configure --cpu=unknown --enable-tcg-interpreter

configure then no longer uses the native linker script (*.ld) for
user mode emulation.

3) Implementation

Like each TCG host frontend, TCI implements the code generator in
tcg-target.inc.c, tcg-target.h. Both files are in directory tcg/tci/.

The additional file tcg/tci.c adds the interpreter.

The bytecode consists of opcodes from include/qemu/tci.h, and a
set of operands:

   31    25  22  19    14               0
  +--------+---+---+-----+---------------+
  |   op   | r | w |  x  |       y       |
  +--------+---+---+-----+---------------+

  Y: Ldst offset, deposit location, binary 2nd argument, unary argument,
     branch displacement, qemu memop, low part input.
  X: Low part store source, deposit field, binary 1st argument,
     high part input
  W: Ldst base, deposit source, high part output
  R: Low part output, high part store source

For both X and Y, values less than 8 refer to a register operand, and
value 8 refers to a follow-on 32-bit signed operand (X coming before Y).
For values larger than 8, the value is biased by 16 and 16768 respectivly.
Thus X can immediately store values 15 to -7, and Y 8191 to -8183, and
both have escapes to a full 32-bit signed operand.

Design considerations:
*  One input (Y) should be able to directly encode most offsets to env.
   This is a range of around -8 < y < 1000.
*  One input (X) should be able to directly encode 0 (sub, deposit)
   and -1 (deposit), as those are common operations.
*  There are several opcodes that need to be able to take 64-bit values,
   particularly on LP64 hosts.
*  Having 2 inputs that can encode arbitrary 32-bit values suggests a
   single 64-bit value can be encoded as a faux binary operation.
*  The X and Y operands should always be decodable, even when unused.
   Thus the literal 0 is ususally stored when the input is unused.
*  Using X as the store (low part) source, as opposed to R or W means
   that 32-bit constants can be stored directly.
